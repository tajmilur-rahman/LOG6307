\documentclass[10pt, conference]{IEEEtran}
\usepackage[english]{babel}
\usepackage[usenames]{color}
\usepackage{colortbl}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{array, colortbl}
\usepackage{listings}
\usepackage{epstopdf}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{caption}
%\usepackage{subfigure}
\usepackage{subfig}
\usepackage{float}
\usepackage[obeyspaces,hyphens,spaces]{url}
\usepackage{balance}
\usepackage{fancybox}
\usepackage{scalefnt}
\usepackage[normalem]{ulem}
%\pagestyle{plain}
\pagenumbering{arabic}
\pagestyle{empty}
\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000
\usepackage{cleveref}

\makeatletter
\renewcommand{\paragraph}[1]{\noindent\textsf{#1}.}

\title{An Empirical Study for Prioritizing Quality Assurance : A Replication Work}
\author{Md Tajmilur Rahman$^{1}$, Louis-Philippe Querel$^{1}$
    \\
	\emph{$^{1}$ Dept. of Computer Science and Engineering, Concordia University, Qu\'{e}bec, Canada}
}


\begin{document}
\maketitle

\begin{abstract}
TODO

\end{abstract}

\section{Introduction}
\label{sec:introduction}

Quality assurance in software development plays the prominent role for a software to turn it into a successful business product. Doing business with a software product by providing services or by selling the software itself demands high level of quality assurance and quality can be assured in software industries by unit test, black-box, white-box, integration, functional and system level testing. Testing is not just the end of the quality assurance but the start of working for assuring quality of a software system. Testing produces list of regressions and flaws throughout the system that keeps the development team busy for fixing bugs to make the system flaw-less. Generally this fixing and testing be practised during the stabilization period once all the new feature development works are done. We can estimate development time and cost prior to a development cycle but the effort that stabilization period consumes for fixing does influence the cost of software product and reputation of the software industry.

In current trend many researchers are focusing on predicting defects in the code-base of the software system~\cite{Gyimothy2005IEEE}. In some contexts this approach can be useful but they have drawbacks. Predicting bugs does not specify the amount of work and cannot minimize the effort in a great deal but comparatively predicting the particular change that could be defect inducing would be more efficient to reduce the effort for fixing bugs around the time of release. This is really important for reducing the stabilization time and releasing the software product sooner to beat competitors in the market.

As most of the quality assurance research works are based on defect prediction on change level we would like to predict defect inducing changes~\cite{Kim2008TSE}. We would like to illustrate the prediction of defect inducing change to enhance software quality by replicating the approach proposed by Kamei et al.~\cite{Kamei2013TSE}. We would like to do this work on a relatively small project DJango based on the following two main research questions:

\textit{RQ1, Prediction:} How well can we predict defect-inducing changes?

Kamei and his co-researchers used six open source projects and five commercial projects. We would like to see how well the model predicts defect-inducing changes in a different software project.

\textit{RQ2, Major Characteristics:} What are the major characteristics of defect-inducing changes?

To answer this research question we want to observe the factors having the largest impact on the predictions. We want to identify the major characteristics of the defect inducing changes and would like to see if the number of files and whether or not the change fixes a defect are risk-increasing factors, also if the average time interval since the previous change is a risk-decreasing factor in RQ1.

\section{Background and Related Work}
\label{sec:backgr-relat-work}

Due to achieve the quality assurance of a software system software engineers and researchers are concerned since many years. Many approaches have been followed and scientists have tried from many different angle to predict defects in software for enhancing quality assurance. Earlier in 2005 Nagappan and T. Ball did an interesting research in Microsoft to predict file level defect density~\cite{Nagappan2005ICSE} based on relative code-churn measure. Later on an approach of predicting defect-prone components has been studied by Nagappan et al. In this study they showed that the change bursts can predict defect-prone components in significantly high rate in comparison to other measures like code-churn or organization structure.

Many other researchers have used change measure, for example Mockus and Weiss~\cite{Mockus2000Bell} used change measures, such as the number of subsystems those are changed, number of modified, lines of code added and the number of modification requests. Now a days churn factor measure become a very traditional approach in predicting defects. From a slightly different angle Sunghun Kim~\cite{Kim2011ICSE} proposes an approach to deal with the noise in defect data as he could realize that automatically collected defect data based on the change logs could include noises.

Many research have been performed comparing open source and commercial projects. Briand et al.~\cite{Briand1999ICSE} did an analysis with the relationship between software design and quality. Zimmermann et al.\cite{Zimmermann2009ESECS} showed that there is no single factor that leads to accurate predictions. They focused on defect prediction from one project to another based on seven commercial projects and four open source projects. Existing research works create the impression that we can predict defects in a software system in many different ways having little variation in accuracy and prediction performance. But this does not help us reducing the fixing time that much. We still need to find out the particular change in the code that is involved in producing the bug.

Previous works are mostly just predicting defects, many of them are also focusing on quality assurance by predicting the probability of defects or the number of defects for a particular location in the system back-end. In contrast to many of these studies Kamei et al.~\cite{Kamei2013TSE} focus on predicting the probability of a software change inducing a defect at check-in time. Actually this research of Kamei et al. made us interested and in this paper we are basically replicating this work o Kamei and his co-workers.

\section{Approach}
\label{sec:approach}
Similarly to Kamei's work, we use a logistic regression model to perform our prediction~\cite{Kamei2013TSE}. We are collecting the historical data of Django from it's git repository and the tables that we generate to store the historical data contains commit information. A commit representing one change here. If a commit contains multiple files then we would like to say these files have got a change at this particular commit. For each commit the logistic regression model outputs a probability represented by a value ranging from 0 to 1. Like Kamei we also set a threshold value of 0.5 to make our prediction easier like: defect-inducing "yes" or "no"~\cite{Gyimothy2005TSE,Guo2010ICSE}.
Kamei et al. selected a minimal set of factors to include as independent variables to avoid over-fitting the models. We followed the exactly similar approach at this point as we are also removing highly correlated factors manually but then instead of using Stepwise variable selection we are using LAR and LASSO methods~\cite{Flom2007NESUG} to remove the remaining collinear metrics and those metrics that do not contribute to the model. This technique begins by centering all the variables and it does scale the covariates. Initially, all parameters are set to 0, and then parameters are added based on correlations with current residual. 
We used accuracy, precision, recall, and F1-measures to evaluate the performance of our model. The confusion matrix has been represented in Table~\ref{table:confusion}. A change True Positive (TP) indicates that the corresponding change is Defect inducing and False Negative (FN) indicates that the change is non-defect-inducing.

For 

Django uses the Trac ticket software system to keep track of tickets which are created for the project. We extracted Some of these tickets (54\%) have a type assigned to them which identify the category of work which it covers. These types can refer to bugs/defects, new features, enhancements and cleanup/optimization ticket tasks. 


\begin{table}
	\onecolumn
	\centering
	\caption{Summary of Change Measures}
\begin{tabular}{|c|l|p{2.5cm}|p{5.5cm}|p{5.25cm}|}
	\hline Dim. & Name & Definition & Rationale & Related Work \\ 
	\hline \multirow{14}{*}{\begin{sideways}Diffusion\end{sideways}} & NS & Number of modified subsystems  & Changes modifying many subsystems are more likely to be defect-prone. & The defect probability of a change increases with the number of modified subsystems \cite{Mockus2000Bell}. \\ \cline{2-5}  
	 & ND & Number of modified directories & Changes touching many files are more likely to be defect-prone. & The higher the number of modified directories, the higher the chance that a change will induce a defect \cite{Mockus2000Bell}. \\ \cline{2-5}  
	 & NF & Number of modified files & Changes touching many files are more likely to be defect-prone. & The number of classes in a module is a good featureof post-release defects of a module \cite{Nagappan2006ICSE}. \\ \cline{2-5} 
	 & Entropy & Distribution of modified code across each file & Changes with high entropy are more likely to be defect-prone, because a developer will have to recall and track large numbers of scattered changes across each file. & Scattered changes are more likely to introduce defects \cite{DAmbross2010MSR}, \cite{Hassan2009ICSE}. \\ 
	\hline \multirow{4}{*}{\begin{sideways}Size\end{sideways}} & LA & Lines of code added & The more lines of code added, the more likely a defect is introduced. & \multirow{2}{5.25cm}{Relative code churn measures are good indicators of defect modules \cite{Moser2008ICSE}, \cite{Nagappan2005ICSE}}. \\ \cline{2-4} 
	  & LD & Lines of code deleted & The more lines of code deleted, the higher the chance of a defect. &  \\ 
	\hline \multirow{4}{*}{\begin{sideways}Purpose\end{sideways}} & FIX & Whether or not the change is defect fix & Fixing a defect means that an error was made in an earlier implementation, therefore it may indicate an area where errors are more likely. & Changes that fix defects are more likely to introduce defects than changes that implement new functionality \cite{Guo2010ICSE}, \cite{Purushothaman2005IEEE}. \\ 
	\hline \multirow{13}{*}{\begin{sideways}History\end{sideways}} & NDEV & The number of developers that changed the modified files & The larger the NDEV, the more likely a defect is introduced, because files revised by many developers often contain different design thoughts and coding styles. & Files previously touched by more developers contain more defects \cite{Matsumoto2010PROMISE}. \\ \cline{2-5} 
	& AGE & The avergae time interval between the last and current change & The lower the AGE (i.e., the more recent the last change), the more likely a defect will be introduced. & More recent changes contribute more defects than older changes \cite{Graves2000IEEE}. \\ \cline{2-5} 
	& NUC & The number of unique changes to the modified files & The larger the NUC, the more likely a defect is introduced, because a developer will have to recalland track many previous changes. & The larger the spread of modified files, the higher the complexity \cite{DAmbross2010MSR}, \cite{Hassan2009ICSE}. \\ 
	\hline \multirow{10}{*}{\begin{sideways}Experience\end{sideways}} & EXP & Developer experience & More experienced developers are less likely to introduced a defect. & Programmer experience significantly decreases the defect probability \cite{Mockus2000Bell}. \\ \cline{2-4} 
	& REXP & Recent developer experience & A developer that has often modified the files in recent months is less likely to introduce defect, because they will be more familiar with recent developments in the system. &  \\ \cline{2-4} 
	& SEXP & Developer experience on a subsystem & Developers that are familiar with the subsystems modified by a change are less likely to introduce defects. &  \\ 
	\hline 
\end{tabular} 

\label{table:factors}
\end{table}
\twocolumn

The following 



\section{Results}
\label{sec:results}

In this section we will be presenting the results of our research questions which replicated the original paper. Django, the project which was selected for this replication is of similar size to other open source projects in the original paper. While Bugzilla is also a web application, it is programmed in a different programming language. As such Django which is a wed development framework written in python will serve to comparision to other open source projects which we being used in the original paper.

\onecolumn
\begin{table}
	\caption{Django Project Statictics}
	\begin{tabular}{|p{2 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|}
		\hline 
		Period  & Total number of commits with changes  & Percentage of defect inducing commits  & Average LOC per file  & Avg. LOC per changes  & \# of modified files per changes  & \# of changes per day  & Max \# dev. per file  & Avg. \# of dev. per file \tabularnewline
		\hline 
		12/07/2005 - 19/09/2014  & 26606  & 28.2\% & 142.5 & 272.3 & 4.6 & 7.9 & 143 & 5.7 \\ \hline 
	\end{tabular}
	\label{table:statistics}	
\end{table}
\twocolumn

\subsection{RQ1: How well can we predict defect-inducing changes?}
\label{sec:rq1}


To avoid the overfitting of factors within the model we used the Using WEKA we can determine 

Using the Weka functiona

Using this model which does nto contain the 

We present the results of the model in Tables \ref{table:confusion} and \ref{table:prediction}. The confusion matrix in table \ref{table:confusion} illustrate the performance of the model which used logistic regression and compares their results to the known values of which change introduced a defect. As illustrated we can see that our model performs better at identifying changes which cahnges are not defect-inducing. On changes which had no defects there was a recall of 95.8\% which reduce the risk of having a false positive. Of the 28.2\% (Table \ref{table:statistics}) of changes which are identified as defect-inducing in our dataset, only 14.6\% of these are recalled by the model. While there would be more instances of false negative, this would result in an increase in the number of defect-inducing changes which might go unnoticied until a defect ticket is openned by a user of the application.  
\begin{table}
	\centering
	\caption{Django Confusion Matrix}
	\begin{tabular}{|c|c|c|}
		\hline 
		true\ classified  & No defect  & defect \tabularnewline
		\hline 
		No defect  & 19121  & 832 \tabularnewline
		\hline 
		defect  & 6413  & 1096 \tabularnewline
		\hline 
	\end{tabular}
	\label{table:confusion}
\end{table}

We used a ZeroR with 10 folds cross validation as our baseline to 

\begin{table}
	\centering
	\caption{Prediction Performance}
	\begin{tabular}{|c|c|c|c|c|}
		\hline Accuracy & Precision & Recall & F1 & AUC\\ 
		\hline 73.6\% & 70\% & 73.6\% & 67.4\% & 69.0\% \\ 
		\hline 
	\end{tabular}
	
	\label{table:prediction} 
\end{table}


\subsection{RQ2: What are the major characteristics of defect-inducing changes?}
\label{sec:rq2}

Using all the factors from our Django model (Table \ref{table:factors}) we can determine which factors are defect-inducing. Compared to the original paper this replication study only covers one open source project. Due to this we will be comparing it to the results of the original paper. 

We followed the approach presented in the original paper of using positive and negative signs to illustrate the effect which a factor as of inducing defects in a change. Factors with a positive sign (+) will result in a higher probability that a change is defect-inducing. On the other hand factors with a negative sign (-) have the opposite effect and reduce the probability that a change is defect inducing.  

Using the odds ratio results obtained from the model which are presented in table \ref{table:odds_ratio} we can determine the effect which these factors have on the probability that it is defect-inducing.  We can see that most factors have a negligable effect when the Django data is modelled. The number of directories in a change (ND) is the biggest defect-inducing factor for Django. Where a change includes modifications to more directories it shall be expected that there will be a higher probability of this change introducing a defect. More of the factors can be said to have a negative effect in inducing defects in Django. The number of subsystem (NS), Entropy and Fix fit within this category for Django. These results would indicate that the more subsystems are modified, the greater the risk of introducing a defect is reduced. The presence of Entropy as a defect-reducing factor would illustrate that the greater the distribution of changes in a Django change the lower the probability that a defet will be introduced. And finally where a change is made to correct an existing defect there is subsequent reduced probability of a defect being present in the lines affected by the change. 

The result of these three factors with a negative effect present a rejection of their rationales as defined in Table \ref{table:factors}. The rationales in Table \ref{table:factors} indicate the expected behaviors of the factors on the probability of inducing-defects, however the project is not required to follow these assumptions as these results illustrate. The results can also be briefly compared to that of the original paper. A more throurough comparision is performed later in section \ref{sec:comparison-results}.  The presence of NS and Fix as defect-reducing factors in the Django data appear to contradict the results which were presented in the original paper.

\begin{table}
	\centering
	\caption{The Impact of Change Factors on Defect-Inducing Changes}
	\begin{tabular}{|c|c|c|c|}
		\hline Metrics name & Impact & Django \\ 
		\hline NS & - & 0.6779 \\ 
		\hline ND & + & 1.0129 \\ 
		\hline NF &  & 1.0007 \\ 
		\hline Entropy & - & 0.6078 \\ 
		\hline LA &  & 1 \\ 
		\hline LD &  & 1 \\ 
		\hline FIX & - & 0.9536 \\ 
		\hline NDEV &  & 0.997 \\ 
		\hline AGE &  & 1.0003 \\ 
		\hline NUC &  & 0.965 \\ 
		\hline EXP &  & 1.0001 \\ 
		\hline REXP &  & 1 \\ 
		\hline SEXP &  & 0.9998 \\ 
		\hline 
	\end{tabular}
	\label{table:odds_ratio}  
\end{table}

The change factor's regression coefficients which are present in Table \ref{table:regression_coefficients} also illustrate similar results to the odds ratios of Table \ref{table:odds_ratio}. The finding which ND is defect-inducing in changes for Django is consistent with the results of the odds ratio in table \ref{table:odds_ratio}. A consistent selection of defect-reducing factors are also present in the regression coefficients in comparision to the odds ratio. The factors NS, Entropy, Fix and NUC would all reduce the probability of a change inducing defects in Django. The defect-reducing effect of NUC would indicate that the more changes which have been applied to a file the less probable it is that this file contains a defect. The defect-reducing effects of NS, Entropy and Fix were presented in a earlier paragraph of this section.
\begin{table}
	\centering
	\caption{The Regression Coefficients of Change Factors}
	\begin{tabular}{|c|c|c|c|}
		\hline Metrics name & Impact & Django \\ 
		\hline NS & - & -0.3887 \\ 
		\hline ND & + & 0.0128 \\ 
		\hline NF &  & 0.0007 \\ 
		\hline Entropy & - & -0.4978 \\ 
		\hline LA &  & 0 \\ 
		\hline LD &  & 0 \\ 
		\hline FIX & - & -0.0475 \\ 
		\hline NDEV &  & -0.003 \\ 
		\hline AGE &  & 0.0003 \\ 
		\hline NUC & - & -0.0356 \\ 
		\hline EXP &  & 0.0001 \\ 
		\hline REXP &  & 0 \\ 
		\hline SEXP &  & -0.0002 \\ 
		\hline 
	\end{tabular}
	\label{table:regression_coefficients} 
\end{table}


\section{Comparison of Results}
\label{sec:comparison-results}

\section{Conclusion}
\label{sec:conclusion}

TODO

\section*{Acknowledgment}
TODO

\balance
\bibliographystyle{IEEEtran}
\bibliography{assignment.bib}
\end{document}
