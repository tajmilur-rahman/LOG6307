\documentclass[10pt, conference]{IEEEtran}
\usepackage[english]{babel}
\usepackage[usenames]{color}
\usepackage{colortbl}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{array, colortbl}
\usepackage{listings}
\usepackage{epstopdf}
\usepackage{multirow}
\usepackage{rotating}
%\usepackage{subfigure}
\usepackage{subfig}
\usepackage{float}
\usepackage[obeyspaces,hyphens,spaces]{url}
\usepackage{balance}
\usepackage{fancybox}
\usepackage{scalefnt}
\usepackage[normalem]{ulem}
%\pagestyle{plain}
\pagenumbering{arabic}
\pagestyle{empty}
\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000
\usepackage{cleveref}

\makeatletter
\renewcommand{\paragraph}[1]{\noindent\textsf{#1}.}

\title{An Empirical Study for Prioritizing Quality Assurance : A Replication Work}
\author{Md Tajmilur Rahman$^{1}$, Loui Philippe Querel$^{1}$
    \\
	\emph{$^{1}$ Dept. of Computer Science and Engineering, Concordia University, Qu\'{e}bec, Canada}
}


\begin{document}
\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam nibh nisi, ultricies a placerat id, pharetra quis arcu. Donec ut rhoncus odio, in luctus turpis. Praesent in tellus in tellus volutpat sagittis non in felis. Praesent commodo, nisl ac ornare porta, quam libero consectetur mi, sed facilisis elit enim non ipsum. Ut consequat eros id ultricies iaculis. Ut pellentesque rhoncus neque. Integer vestibulum ac diam vitae faucibus. Sed sit amet viverra enim. Suspendisse eu nulla vel turpis auctor posuere sit amet non metus.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Quality assurance in software development plays the prominent role for a software to turn it into a successful business product. Doing business with a software product by providing services or by selling the software itself demands high level of quality assurance and quality can be assured in software industries by unit test, black-box, white-box, integration, functional and system level testing. Testing is not just the end of the quality assurance but the start of working for assuring quality of a software system. Testing produces list of regressions and flaws throughout the system that keeps the development team busy for fixing bugs to make the system flaw-less. Generally this fixing and testing be practised during the stabilization period once all the new feature development works are done. We can estimate development time and cost prior to a development cycle but the effort that stabilization period consumes for fixing does influence the cost of software product and reputation of the software industry. 

In current trend many researchers are focusing on predicting defects in the code-base of the software system~\cite{Gyimothy2005IEEE}. In some contexts this approach can be useful but they have drawbacks. Predicting bugs does not specify the amount of work and cannot minimize the effort in a great deal but comparatively predicting the particular change that could be defect inducing would be more efficient to reduce the effort for fixing bugs around the time of release. This is really important for reducing the stabilization time and releasing the software product sooner to beat competitors in the market.

\section{Background and Related Work}
\label{sec:backgr-relat-work}

Due to achieve the quality assurance of a software system software engineers and researchers are concerned since many years. Many approaches have been followed and scientists have tried from many different angle to predict defects in software for enhancing quality assurance. Earlier in 2005 Nagappan and T. Ball did an interesting research in Microsoft to predict file level defect density~\cite{Nagappan2005ICSE} based on relative code-churn measure. Later on an approach of predicting defect-prone components has been studied by Nagappan et al. In this study they showed that the change bursts can predict defect-prone components in significantly high rate in comparison to other measures like code-churn or organization structure.

Many other researchers have used change measure, for example Mockus and Weiss~\cite{Mockus2000Bell} used change measures, such as the number of subsystems those are changed, number of modified, lines of code added and the number of modification requests. Now a days churn factor measure become a very traditional approach in predicting defects. From a slightly different angle Sunghun Kim~\cite{Kim2011ICSE} proposes an approach to deal with the noise in defect data as he could realize that automatically collected defect data based on the change logs could include noises.

Many research have been performed comparing open source and commercial projects. Briand et al.~\cite{Briand1999ICSE} did an analysis with the relationship between software design and quality. Zimmermann et al.\cite{Zimmermann2009ESECS} showed that there is no single factor that leads to accurate predictions. They focused on defect prediction from one project to another based on seven commercial projects and four open source projects. Existing research works create the impression that we can predict defects in a software system in many different ways having little variation in accuracy and prediction performance. But this does not help us reducing the fixing time that much. We still need to find out the particular change in the code that is involved in producing the bug.


\section{Approach}
\label{sec:approach}
Similarly to previous work, we use a logistic regression model to perform our prediction [4], [8], [17]. The logistic regression model outputs a probability, i.e., a value between 0 and 1, for each change. We use a threshold value of 0.5, which means that if the model-predicted probability of a defect is greater than 0.5, the change is classified as defect inducing; otherwise, it is classified as non-defect-inducing [16], [17]. To avoid overfitting our models, we select a minimal set of factors to include as independent variables of the models. First, we manually remove highly correlated factors, then we use stepwise variable selection based on Mallowsâ€™ Cp criterion [31] to remove the remaining collinear metrics and those metrics that do not contribute to the model. This selection technique proceeds by deleting the worst variable from the full model until deleting any remaining variables would no longer be beneficial. To evaluate the prediction performance, we employ the commonly used accuracy, precision, recall, and F1-measures. These measures can be derived from a confusion matrix, as shown in Table 3. A change can be classified as defect inducing when it is truly defect inducing (true positive, TP); it can be classified as defect inducing when it is actually not (false positive, FP); it can be classified as non-defect-inducing when it is actually defect inducing (false negative, FN); or it can be correctly classified as non-defect-inducing (true negative, TN).
\onecolumn
\begin{tabular}{|c|l|p{3cm}|p{6cm}|l|}
	\hline Dim. & Name & Definition & Rationale & Related Work \\ 
	\hline \multirow{10}{*}{\begin{sideways}Diffusion\end{sideways}} & NS & Number of modified subsystems  & Changes modifying many subsystems are more likely to be defect-prone. &  \\ \cline{2-5}  
	 & ND & Number of modified directories & Changes touching many files are more likely to be defect-prone. &  \\ \cline{2-5}  
	 & NF & Number of modified files & Changes touching many files are more likely to be defect-prone. &  \\ \cline{2-5} 
	 & Entropy & Distribution of modified code across each file & Changes with high entropy are more likely to be defect-prone, because a developer will have to recall and track large numbers of scattered changes across each file. &  \\ 
	\hline \multirow{2}{*}{\begin{sideways}Size\end{sideways}} & LA & Lines of code added & The more lines of code added, the more likely a defect is introduced. &  \\ \cline{2-5} 
	  & LD & Lines of code deleted & The more lines of code deleted, the higher the chance of a defect. &  \\ 
	\hline Purpose & FIX & Whether or not the change is defect fix & Fixing a defect means that an error was made in an earlier implementation, therefore it may indicate an area where errors are more likely. &  \\ 
	\hline \multirow{3}{*}{\begin{sideways}History\end{sideways}} & NDEV & The number of developers that changed the modified files & The larger the NDEV, the more likely a defect is introduced, because files revised by many developers often contain different design thoughts and coding styles. &  \\ \cline{2-5} 
	& AGE & The avergae time interval between the last and current change & The lower the AGE (i.e., the more recent the last change), the more likely a defect will be introduced. &  \\ \cline{2-5} 
	& NUC & The number of unique changes to the modified files & The larger the NUC, the more likely a defect is introduced, because a developer will have to recalland track many previous changes. &  \\ 
	\hline \multirow{3}{*}{\begin{sideways}Experience\end{sideways}} & EXP & Developer experience & More experienced developers are less likely to introduced a defect. &  \\ \cline{2-5} 
	& REXP & Recent developer experience & A developer that has often modified the files in recent months is less likely to introduce defect, because they will be more familiar with recent developments in the system. &  \\ \cline{2-5} 
	& SEXP & Developer experience on a subsystem & Developers that are familiar with the subsystems modified by a change are less likely to introduce defects. &  \\ 
	\hline 
\end{tabular} 

\twocolumn
\section{Results}
\label{sec:results}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
	\hline 
	Period  & Total number of commits with changes  & Percentage of defect inducing commits  & Average LOC per file  & Avg. LOC per changes  & \# of modified files per changes  & \# of changes per day  & Max \# dev. per file  & Avg. \# of dev. per file \tabularnewline
	\hline 
	12/07/2005 - 19/09/2014  & 26606  & 28.2% & 142.5 & 272.3 & 4.6 & 7.9 & 143 & 5.7 \\ 
	&  &  &  &  &  & \tabularnewline
\end{tabular}


\subsection{RQ1: How well can we predict defect-inducing changes?}
\label{sec:rq1}


\subsection{RQ2: What are the major characteristics of defect-inducing changes?}
\label{sec:rq2}

\begin{tabular}{|c|c|c|}
	\hline 
	true\ classified  & No defect  & defect \tabularnewline
	\hline 
	No defect  & 19068  & 885 \tabularnewline
	\hline 
	defect  & 6350  & 1159 \tabularnewline
	\hline 
\end{tabular}


\section{Comparison of Results}
\label{sec:comparison-results}

\section{Conclusion}
\label{sec:conclusion}

Sed ullamcorper augue a lectus mollis gravida. Aliquam in commodo tortor, eget dignissim velit. Phasellus suscipit felis non nisl consequat, quis tempus sapien volutpat. Pellentesque a sagittis lectus. Nunc quis pulvinar velit, quis auctor nisl. In sed erat lectus. Vivamus eget justo et urna consequat consequat. Praesent id nisl odio. Vestibulum aliquam sit amet risus vel pretium. Aenean blandit diam at sem vulputate, sed lobortis magna vulputate. Curabitur nisi velit, tempor ut elit non, aliquet tristique sem. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Vestibulum quis sollicitudin libero.

\section*{Acknowledgment}
TODO

\balance
\bibliographystyle{IEEEtran}
\bibliography{assignment.bib}
\end{document}
