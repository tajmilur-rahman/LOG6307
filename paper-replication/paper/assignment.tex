\documentclass[10pt, conference]{IEEEtran}
\usepackage[english]{babel}
\usepackage[usenames]{color}
\usepackage{colortbl}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{array, colortbl}
\usepackage{listings}
\usepackage{epstopdf}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{caption}
%\usepackage{subfigure}
\usepackage{subfig}
\usepackage{float}
\usepackage[obeyspaces,hyphens,spaces]{url}
\usepackage{balance}
\usepackage{fancybox}
\usepackage{scalefnt}
\usepackage[normalem]{ulem}
%\pagestyle{plain}
\pagenumbering{arabic}
\pagestyle{empty}
\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000
\usepackage{cleveref}

\makeatletter
\renewcommand{\paragraph}[1]{\noindent\textsf{#1}.}

\title{An Empirical Study for Prioritizing Quality Assurance : A Replication Work}
\author{Md Tajmilur Rahman$^{1}$, Louis-Philippe Querel$^{1}$
    \\
	\emph{$^{1}$ Dept. of Computer Science and Engineering, Concordia University, Qu\'{e}bec, Canada}
}


\begin{document}
\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam nibh nisi, ultricies a placerat id, pharetra quis arcu. Donec ut rhoncus odio, in luctus turpis. Praesent in tellus in tellus volutpat sagittis non in felis. Praesent commodo, nisl ac ornare porta, quam libero consectetur mi, sed facilisis elit enim non ipsum. Ut consequat eros id ultricies iaculis. Ut pellentesque rhoncus neque. Integer vestibulum ac diam vitae faucibus. Sed sit amet viverra enim. Suspendisse eu nulla vel turpis auctor posuere sit amet non metus.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Quality assurance in software development plays the prominent role for a software to turn it into a successful business product. Doing business with a software product by providing services or by selling the software itself demands high level of quality assurance and quality can be assured in software industries by unit test, black-box, white-box, integration, functional and system level testing. Testing is not just the end of the quality assurance but the start of working for assuring quality of a software system. Testing produces list of regressions and flaws throughout the system that keeps the development team busy for fixing bugs to make the system flaw-less. Generally this fixing and testing be practised during the stabilization period once all the new feature development works are done. We can estimate development time and cost prior to a development cycle but the effort that stabilization period consumes for fixing does influence the cost of software product and reputation of the software industry. 

In current trend many researchers are focusing on predicting defects in the code-base of the software system~\cite{Gyimothy2005IEEE}. In some contexts this approach can be useful but they have drawbacks. Predicting bugs does not specify the amount of work and cannot minimize the effort in a great deal but comparatively predicting the particular change that could be defect inducing would be more efficient to reduce the effort for fixing bugs around the time of release. This is really important for reducing the stabilization time and releasing the software product sooner to beat competitors in the market.

\section{Background and Related Work}
\label{sec:backgr-relat-work}

Due to achieve the quality assurance of a software system software engineers and researchers are concerned since many years. Many approaches have been followed and scientists have tried from many different angle to predict defects in software for enhancing quality assurance. Earlier in 2005 Nagappan and T. Ball did an interesting research in Microsoft to predict file level defect density~\cite{Nagappan2005ICSE} based on relative code-churn measure. Later on an approach of predicting defect-prone components has been studied by Nagappan et al. In this study they showed that the change bursts can predict defect-prone components in significantly high rate in comparison to other measures like code-churn or organization structure.

Many other researchers have used change measure, for example Mockus and Weiss~\cite{Mockus2000Bell} used change measures, such as the number of subsystems those are changed, number of modified, lines of code added and the number of modification requests. Now a days churn factor measure become a very traditional approach in predicting defects. From a slightly different angle Sunghun Kim~\cite{Kim2011ICSE} proposes an approach to deal with the noise in defect data as he could realize that automatically collected defect data based on the change logs could include noises.

Many research have been performed comparing open source and commercial projects. Briand et al.~\cite{Briand1999ICSE} did an analysis with the relationship between software design and quality. Zimmermann et al.\cite{Zimmermann2009ESECS} showed that there is no single factor that leads to accurate predictions. They focused on defect prediction from one project to another based on seven commercial projects and four open source projects. Existing research works create the impression that we can predict defects in a software system in many different ways having little variation in accuracy and prediction performance. But this does not help us reducing the fixing time that much. We still need to find out the particular change in the code that is involved in producing the bug.

Previous works are mostly just predicting defects, many of them are also focusing on quality assurance by predicting the probability of defects or the number of defects for a particular location in the system back-end. In contrast to many of these studies Kamei et al.~\cite{Kamei2013TSE} focus on predicting the probability of a software change inducing a defect at check-in time. Actually this research of Kamei et al. made us interested and in this paper we are basically replicating this work o Kamei and his co-workers.

\section{Approach}
\label{sec:approach}
Similarly to Kamei's work, we use a logistic regression model to perform our prediction~\cite{Kamei2013TSE}. We are collecting the historical data of Django from it's git repository and the tables that we generate to store the historical data contains commit information. A commit representing one change here. If a commit contains multiple files then we would like to say these files have got a change at this particular commit. For each commit the logistic regression model outputs a probability represented by a value ranging from 0 to 1. Like Kamei we also set a threshold value of 0.5 to make our prediction easier like: defect-inducing "yes" or "no"~\cite{Gyimothy2005TSE,Guo2010ICSE}.
Kamei et al. selected a minimal set of factors to include as independent variables to avoid over-fitting the models. We followed the exactly similar approach at this point as we are also removing highly correlated factors manually but then instead of using Stepwise variable selection we are using LAR and LASSO methods~\cite{Flom2007NESUG} to remove the remaining collinear metrics and those metrics that do not contribute to the model. This technique begins by centering all the variables and it does scale the covariates. Initially, all parameters are set to 0, and then parameters are added based on correlations with current residual. 
We used accuracy, precision, recall, and F1-measures to evaluate the performance of our model. The confusion matrix has been represented in Table~\ref{table:confusion}. A change True Positive (TP) indicates that the corresponding change is Defect inducing and False Negative (FN) indicates that the change is non-defect-inducing.

Django uses the Git.   

Django uses the Trac ticket software system to keep track of tickets which are created for the project. We extracted Some of these tickets (54\%) have a type assigned to them which identify the category of work which it covers. These types can refer to bugs/defects, new features, enhancements and cleanup/optimization ticket tasks. 


\begin{table}
	\onecolumn
	\centering
	\caption{Summary of Change Measures}
\begin{tabular}{|c|l|p{2.5cm}|p{5.5cm}|p{5.25cm}|}
	\hline Dim. & Name & Definition & Rationale & Related Work \\ 
	\hline \multirow{14}{*}{\begin{sideways}Diffusion\end{sideways}} & NS & Number of modified subsystems  & Changes modifying many subsystems are more likely to be defect-prone. & The defect probability of a change increases with the number of modified subsystems \cite{Mockus2000Bell}. \\ \cline{2-5}  
	 & ND & Number of modified directories & Changes touching many files are more likely to be defect-prone. & The higher the number of modified directories, the higher the chance that a change will induce a defect \cite{Mockus2000Bell}. \\ \cline{2-5}  
	 & NF & Number of modified files & Changes touching many files are more likely to be defect-prone. & The number of classes in a module is a good featureof post-release defects of a module \cite{Nagappan2006ICSE}. \\ \cline{2-5} 
	 & Entropy & Distribution of modified code across each file & Changes with high entropy are more likely to be defect-prone, because a developer will have to recall and track large numbers of scattered changes across each file. & Scattered changes are more likely to introduce defects \cite{DAmbross2010MSR}, \cite{Hassan2009ICSE}. \\ 
	\hline \multirow{4}{*}{\begin{sideways}Size\end{sideways}} & LA & Lines of code added & The more lines of code added, the more likely a defect is introduced. & \multirow{2}{5.25cm}{Relative code churn measures are good indicators of defect modules \cite{Moser2008ICSE}, \cite{Nagappan2005ICSE}}. \\ \cline{2-4} 
	  & LD & Lines of code deleted & The more lines of code deleted, the higher the chance of a defect. &  \\ 
	\hline \multirow{4}{*}{\begin{sideways}Purpose\end{sideways}} & FIX & Whether or not the change is defect fix & Fixing a defect means that an error was made in an earlier implementation, therefore it may indicate an area where errors are more likely. & Changes that fix defects are more likely to introduce defects than changes that implement new functionality \cite{Guo2010ICSE}, \cite{Purushothaman2005IEEE}. \\ 
	\hline \multirow{13}{*}{\begin{sideways}History\end{sideways}} & NDEV & The number of developers that changed the modified files & The larger the NDEV, the more likely a defect is introduced, because files revised by many developers often contain different design thoughts and coding styles. & Files previously touched by more developers contain more defects \cite{Matsumoto2010PROMISE}. \\ \cline{2-5} 
	& AGE & The avergae time interval between the last and current change & The lower the AGE (i.e., the more recent the last change), the more likely a defect will be introduced. & More recent changes contribute more defects than older changes \cite{Graves2000IEEE}. \\ \cline{2-5} 
	& NUC & The number of unique changes to the modified files & The larger the NUC, the more likely a defect is introduced, because a developer will have to recalland track many previous changes. & The larger the spread of modified files, the higher the complexity \cite{DAmbross2010MSR}, \cite{Hassan2009ICSE}. \\ 
	\hline \multirow{10}{*}{\begin{sideways}Experience\end{sideways}} & EXP & Developer experience & More experienced developers are less likely to introduced a defect. & Programmer experience significantly decreases the defect probability \cite{Mockus2000Bell}. \\ \cline{2-4} 
	& REXP & Recent developer experience & A developer that has often modified the files in recent months is less likely to introduce defect, because they will be more familiar with recent developments in the system. &  \\ \cline{2-4} 
	& SEXP & Developer experience on a subsystem & Developers that are familiar with the subsystems modified by a change are less likely to introduce defects. &  \\ 
	\hline 
\end{tabular} 

\label{table:factors}
\end{table}
\twocolumn

The following 


\onecolumn
\section{Results}
\label{sec:results}

\begin{table}
	\caption{Django Project Statictics}
	\begin{tabular}{|p{2 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|p{1.5 cm}|}
		\hline 
		Period  & Total number of commits with changes  & Percentage of defect inducing commits  & Average LOC per file  & Avg. LOC per changes  & \# of modified files per changes  & \# of changes per day  & Max \# dev. per file  & Avg. \# of dev. per file \tabularnewline
		\hline 
		12/07/2005 - 19/09/2014  & 26606  & 28.2\% & 142.5 & 272.3 & 4.6 & 7.9 & 143 & 5.7 \\ \hline 
	\end{tabular}
	\label{table:statistics}	
\end{table}
\twocolumn

\subsection{RQ1: How well can we predict defect-inducing changes?}
\label{sec:rq1}


To avoid the overfitting of factors within the model we used the Using WEKA we can determine 

Using this model which does nto contain the 
\begin{table}
	\centering
	\caption{Django Confusion Matrix}
	\begin{tabular}{|c|c|c|}
		\hline 
		true\ classified  & No defect  & defect \tabularnewline
		\hline 
		No defect  & 19121  & 832 \tabularnewline
		\hline 
		defect  & 6413  & 1096 \tabularnewline
		\hline 
	\end{tabular}
	\label{table:confusion}
\end{table}

\begin{table}
	\centering
	\caption{Prediction Performance}
	\begin{tabular}{|c|c|c|c|c|}
		\hline Accuracy & Precision & Recall & F1 & AUC\\ 
		\hline 73.6\% & 70\% & 73.6\% & 67.4\% & 69.0\% \\ 
		\hline 
	\end{tabular}
	
	\label{table:prediction} 
\end{table}


\subsection{RQ2: What are the major characteristics of defect-inducing changes?}
\label{sec:rq2}

Using the factors from the model we can determine which of these are defect-inducing. Given that this replication study only covers one open source project and no commercial projects compared to the original paper we will not cons. Using the full dataset we can evaluate the characteristics of defect inducing changes.

We followed the approach presented in the original paper of using positive and negative signs to illustrate the effect which a factor as of inducing defects in a change. Factors with a positive sign (+) will result in a higher probability that a change is defect-inducing. On the other hand factors with a negative sign (-) have the opposite effect and reduce the probability that a change is defect inducing.  

Using the odds ratio results obtained from the model which are presented in table \ref{table:odds_ratio} we can determine the effect which these factors have on the probability that it is defect-inducing.  We can see that most factors have a negligable effect when the Django data is modelled. The number of directories in a change (ND) is the biggest defect-inducing factor for Django. More of the factors can be said to have a negative effect in inducing defects in Django. The number of subsystem (NS), Entropy and Fix fit within this category for Django. The presence of NS and Fix in the Django data appear to contradict the results which were presented in the original paper.

\begin{table}
	\centering
	\caption{The Impact of Change Factors on Defect-Inducing Changes}
	\begin{tabular}{|c|c|c|c|}
		\hline Metrics name & Impact & Django \\ 
		\hline NS & - & 0.6779 \\ 
		\hline ND & + & 1.0129 \\ 
		\hline NF &  & 1.0007 \\ 
		\hline Entropy & - & 0.6078 \\ 
		\hline LA &  & 1 \\ 
		\hline LD &  & 1 \\ 
		\hline FIX & - & 0.9536 \\ 
		\hline NDEV &  & 0.997 \\ 
		\hline AGE &  & 1.0003 \\ 
		\hline NUC &  & 0.965 \\ 
		\hline EXP &  & 1.0001 \\ 
		\hline REXP &  & 1 \\ 
		\hline SEXP &  & 0.9998 \\ 
		\hline 
	\end{tabular}
	\label{table:odds_ratio}  
\end{table}

Table \ref{table:regression_coefficients}

\begin{table}
	\centering
	\caption{The Regression Coefficients of Change Factors}
	\begin{tabular}{|c|c|c|c|}
		\hline Metrics name & Impact & Django \\ 
		\hline NS & - & -0.3887 \\ 
		\hline ND & + & 0.0128 \\ 
		\hline NF &  & 0.0007 \\ 
		\hline Entropy & - & -0.4978 \\ 
		\hline LA &  & 0 \\ 
		\hline LD &  & 0 \\ 
		\hline FIX & - & -0.0475 \\ 
		\hline NDEV &  & -0.003 \\ 
		\hline AGE &  & 0.0003 \\ 
		\hline NUC & - & -0.0356 \\ 
		\hline EXP &  & 0.0001 \\ 
		\hline REXP &  & 0 \\ 
		\hline SEXP &  & -0.0002 \\ 
		\hline 
	\end{tabular}
	\label{table:regression_coefficients} 
\end{table}


\section{Comparison of Results}
\label{sec:comparison-results}

\section{Conclusion}
\label{sec:conclusion}

Sed ullamcorper augue a lectus mollis gravida. Aliquam in commodo tortor, eget dignissim velit. Phasellus suscipit felis non nisl consequat, quis tempus sapien volutpat. Pellentesque a sagittis lectus. Nunc quis pulvinar velit, quis auctor nisl. In sed erat lectus. Vivamus eget justo et urna consequat consequat. Praesent id nisl odio. Vestibulum aliquam sit amet risus vel pretium. Aenean blandit diam at sem vulputate, sed lobortis magna vulputate. Curabitur nisi velit, tempor ut elit non, aliquet tristique sem. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Vestibulum quis sollicitudin libero.

\section*{Acknowledgment}
TODO

\balance
\bibliographystyle{IEEEtran}
\bibliography{assignment.bib}
\end{document}
